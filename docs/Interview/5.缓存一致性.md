# 5.缓存一致性

**缓存使用场景:**

1. **用户身份验证 (Token 缓存):**
   - **目的:** 提高用户身份验证效率，减轻数据库压力。
   - **缓存内容:** 用户登录成功后生成的 **Token** 令牌。
   - **缓存 Key:** Token 值本身。
   - **缓存 Value:** 与 Token 关联的用户信息 (例如用户名)。
   - **使用场景:** 每次接收到需要身份验证的 API 请求时，服务端首先 **查询 Redis 缓存** 验证 Token 的有效性，而不是每次都查询数据库。 只有在 Redis 中找不到 Token 记录时，才认为 Token 无效。
2. **共享图片信息缓存:**
   - **目的:** 加速共享图片的浏览访问，减少数据库读取压力。
   - **缓存内容:** 用户分享的图片信息，包括：
     - 图片下载 URL (file_url)
     - 分享者用户名 (user)
     - 图片文件名 (file_name)
     - 浏览次数 (pv)
     - 文件大小 (size)
     - 创建时间 (create_time)
   - **缓存 Key:** 分享链接的唯一标识符 urlmd5。
   - **缓存 Value:** 使用 **Hash 结构** 存储上述图片信息字段。
   - **使用场景:** 当用户访问分享链接浏览图片时，服务端首先根据 urlmd5 **查询 Redis 缓存** 获取图片信息。 如果 Redis 中存在缓存，则直接返回缓存数据，无需查询数据库。 只有在 Redis 缓存未命中时，才会 **回退到 MySQL 数据库查询 (share_picture_list2 表)**，并将查询结果 **缓存到 Redis 中**，以便下次访问加速。
3. **共享文件下载排行榜缓存:**
   - **目的:** 高效地展示热门共享文件的下载排行榜。
   - **缓存内容:** 共享文件的下载量 (pv) 排行榜数据。
   - **缓存结构:** 使用 **Redis 的 ZSET (Sorted Set) 数据结构** 来存储排行榜数据。
   - **ZSET Member:** 文件的唯一标识符 (例如 md5 + filename)。
   - **ZSET Score:** 文件的下载量 (pv)，用于排序。
   - **使用场景:** 当客户端请求获取共享文件下载排行榜时，服务端直接从 Redis 的 ZSET 中 **读取排行榜数据**，并按下载量排序返回，避免了频繁查询数据库和排序操作。

**缓存数据一致性维护:**

项目文档中关于缓存一致性的策略描述相对简洁，但我们可以根据文档和常见的缓存策略进行推断和分析：

1. **Token 缓存一致性:**
   - **策略:** **基于过期时间 (TTL) 的缓存 + 主动删除 (Logout)。**
   - **机制:** Token 在 Redis 中通常会设置一个 **较短的过期时间 (TTL)**。 当 Token 过期后，Redis 会自动删除缓存，客户端需要重新登录获取新的 Token。 用户 **主动注销登录时，服务端应该显式地从 Redis 中删除对应的 Token 缓存**，强制 Token 失效。
   - **一致性:** Token 缓存的一致性主要依赖于过期时间和主动删除机制。 由于 Token 的生命周期较短，即使缓存略有延迟，也不会对用户体验造成太大影响。
2. **共享图片信息缓存一致性:**
   - **策略:** **Cache-Aside (旁路缓存) 策略 + 延迟双写 (Delayed Write-Through) + 定期刷新 (PV 计数)。**
   - **Cache-Aside:** 应用服务器负责维护缓存和数据库的一致性。 读取数据时，先查缓存，缓存未命中再查数据库，并回写缓存。 更新数据时，先更新数据库，然后 **删除缓存** (或更新缓存，本项目可能选择删除缓存以简化操作)。
   - **延迟双写 (PV 计数):** 文档提到 "redis存储的pv值实时更新，msyql的share_picture_list2的pv每隔5个计数刷新一次"。 这暗示了 **PV 计数的更新可能不是强一致性的**。 每次图片浏览时，PV 值会实时更新到 Redis 缓存，但 **定期 (例如每隔 5 个计数) 才将 Redis 中的 PV 值刷新回 MySQL 数据库**。 这种延迟双写策略可以降低数据库的写入压力，但可能存在 **短暂的数据不一致性** (Redis 中的 PV 值可能比 MySQL 数据库中的 PV 值略高，但误差在可接受范围内)。
   - **缓存失效:** 当图片分享信息发生变化时 (例如取消分享、图片被删除等)，需要 **删除 Redis 中对应的缓存**，以保证下次访问时能从数据库中获取最新的数据。
   - **一致性:** 共享图片信息缓存的一致性主要通过 Cache-Aside 策略和缓存失效机制来保证。 PV 计数使用了延迟双写策略，允许一定的 **最终一致性**。
3. **共享文件下载排行榜缓存一致性:**
   - **策略:** **数据直接写入 Redis (ZSET) + 定期或事件触发更新。**
   - **机制:** 排行榜数据直接存储在 Redis ZSET 中，数据的更新 (例如下载量增加) **直接操作 Redis ZSET**。
   - **数据持久化:** 为了防止 Redis 数据丢失，需要配置 Redis 的 **持久化机制** (例如 RDB 或 AOF)。
   - **排行榜重建或更新:** 排行榜的更新可以采用 **定期重建** (例如每天定时重新计算排行榜) 或 **事件触发更新** (例如每次文件下载成功后，实时更新排行榜)。 文档中没有详细说明排行榜的更新策略，但推测可能是定期重建或基于下载事件的异步更新。
   - **一致性:** 排行榜缓存的一致性主要依赖于 Redis 本身的数据持久化和更新机制。 由于排行榜数据允许一定的 **最终一致性**，即使缓存略有延迟，也不会对核心功能造成影响。

**总结:**

项目在用户身份验证、共享图片浏览和排行榜等场景中都使用了 Redis 缓存，以提高性能和降低数据库压力。 缓存一致性维护方面，主要采用了 **Cache-Aside 策略、过期机制、主动删除、延迟双写** 等策略。 对于 PV 计数这类非核心数据，允许一定的 **最终一致性**，而对于用户身份、图片元数据等核心数据，则尽量保证 **强一致性** (或最终一致性，但尽量缩短不一致的时间窗口)。