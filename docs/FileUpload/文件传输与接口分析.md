# 1. 数据库设计
## 1.1 用户注册和登录
### 1.1.1 用户信息表(user_info)
| 字段名      | 中文含义   | 类型        | 是否允许空 | 默认值           | 其他                     |
|-------------|------------|-------------|------------|------------------|--------------------------|
| id          | 序号       | bigint      | 否         |                  | 自动递增，主键           |
| user_name   | 用户名称   | varchar(32) | 否         | ""               | 唯一                     |
| nick_name   | 用户昵称   | varchar(32) | 否         | ""               |                          |
| phone       | 手机号码   | varchar(16) | 否         | ""               |                          |
| email       | 邮箱       | varchar(64) | 否         | ""               |                          |
| password    | 密码       | varchar(32) | 是         | ""               | 保存md5后的加密值        |
| create_time | 用户创建时间 | TIMESTAMP  | 否         | CURRENT_TIMESTAMP |                          |


## 1.2 我的文件列表
### 1.2.1 用户文件列表(user_file_list)
| 字段名        | 中文含义     | 类型         | 是否允许空 | 默认值           | 其他                                   |
|---------------|--------------|--------------|------------|------------------|----------------------------------------|
| id            | 序号         | int          | 否         |                  | 自动递增，主键                         |
| user          | 文件所属用户 | varchar(32)  | 否         |                  |                                        |
| md5           | 文件md5      | varchar(256) | 否         |                  |                                        |
| file_name     | 文件名字     | varchar(128) | 否         | ""               |                                        |
| shared_status | 共享状态     | int          | 否         | 0                | 0为没有共享，1为共享                   |
| pv            | 文件下载量   | int          | 否         | 0                | 默认值为0，下载一次加1                 |
| create_time   | 文件创建时间 | timestamp    | 否         | CURRENT_TIMESTAMP |                                        |

### 1.2.2 文件信息表(file_info)

| 字段名  | 中文含义    | 类型         | 是否允许空 | 默认值 | 其他                                      |
|---------|-------------|--------------|------------|--------|-------------------------------------------|
| id      | 序号        | bigint       | 否         | ""     | 自动递增，主键                            |
| md5     | 文件md5     | varchar(256) | 否         | ""     |                                           |
| file_id | 文件id      | varchar(256) | 否         | ""     | 格式例如：/group1/M00/00/00/xxx.png       |
| url     | 文件url     | varchar(512) | 否         | ""     | 格式例如：192.168.1.2:80/group1/M00/00/00/xxx.png |
| size    | 文件大小    | bigint       | 否         | 0      | 以字节为单位                              |
| type    | 文件类型    | varchar(32)  | 是         | ""     | png, zip, mp4......                       |
| count   | 文件引用计数 | int     | 否         | 0      | 默认为1，每增加一个用户拥有此文件，此计数器+1 |


# 2. reactor + http框架
## 2.1 后台处理框架
1. **客户端 (Client):**  用户通过浏览器或其他客户端发起请求。

2. **Nginx 代理 (Nginx Proxy):**  作为系统的入口，接收客户端请求，并根据请求的 URI 将请求路由到不同的后端服务。 Nginx 这里充当了 **反向代理** 和 **负载均衡** 的角色。   `nginx-upload-module` 和 `fastdfs-nginx-module`实现 Nginx 文件上传和 FastDFS 文件存储的功能。

3. **API 接口服务 (API Endpoints):**  Nginx 根据请求 URI 将请求转发到不同的 API 服务，这些服务负责处理具体的业务逻辑。
    * `/api/reg`:  注册 (api_register.cc)
    * `/api/login`: 登录 (api_login.cc)
    * `/api/myfiles`: 我的文件 (api_myfiles.cc)
    * `/api/sharefiles`: 共享文件列表 (api_sharefiles.cc)
    * `/api/dealfile`: 处理文件 (api_dealfile.cpp)
    * `/api/dealsharefile`: 处理共享文件 (api_deal_sharefile.cpp)
    * `/api/sharepic`:  图片分享 (api_sharepicture.cpp)
    * `/api/md5`:  处理秒传/MD5校验 (api_md5.cc)
    * `/api/upload`:  上传文件 (api_upload.cc)

4. **MySQL 数据库 (MySQL):**  用于存储 **结构化数据**，例如用户信息、用户关系、文件元数据等。  API 服务会与 MySQL 数据库进行交互，进行数据查询和存储操作。

5. **Redis 缓存 (Redis):**  用于 **缓存** 热点数据，例如用户会话信息、频繁访问的文件信息等，以提高系统性能，减轻 MySQL 数据库的压力。  部分 API 服务可能会与 Redis 缓存进行交互。

6. **FastDFS 分布式文件系统 (FastDFS):**  用于存储 **非结构化数据**，即用户上传的文件。 FastDFS 由 **Tracker 服务器 (Tracker)** 和 **存储服务器组 (Storage Group)** 组成：
    * **Tracker 服务器 (Tracker):**  负责管理存储服务器，维护文件索引信息，并为客户端提供文件上传和下载的路由。
    * **存储服务器组 (Storage Group):** 由多个 **存储服务器 (Storage)** 组成，实际存储文件数据。  每个 Storage Group 内部的存储服务器之间进行 **数据同步**，保证数据的高可用性和冗余性。

7. **文件下载 (File Download):**  通过 `fastdfs-nginx-module` 模块，Nginx 可以直接从 FastDFS 存储服务器下载文件，并返回给客户端。

**整体流程概括:**

客户端请求首先到达 Nginx 代理，Nginx 根据请求 URI 将请求路由到相应的 API 服务。 API 服务处理业务逻辑，可能与 MySQL 数据库和 Redis 缓存进行数据交互。  对于文件上传请求，文件会存储到 FastDFS 分布式文件系统中。  文件下载请求则通过 Nginx 和 FastDFS 模块直接从 FastDFS 下载文件。


## 2.2 reactor网络模型
1. 客户端发送 HTTP 请求。
2. Reactor 单线程通过 `epoll_wait` 接收请求数据，并组装成完整的 HTTP 请求。
3. Reactor 将 HTTP 请求封装成任务，放入线程池的任务队列。
4. 线程池中的工作线程从任务队列中取出任务进行处理，处理过程中可能使用 MySQL 连接池访问 MySQL 数据库，或者使用 Redis 连接池访问 Redis 缓存。
5. 工作线程处理完成后，将需要返回给客户端的数据放入数据队列。
6. Reactor 线程从数据队列中取出数据，通过 `http_loop_callback` 回调函数将数据发送回客户端。

## 2.3 http业务构建
### 2.3.1 main函数处理流程
1. **获取配置文件路径 :**  程序启动时，首先需要确定配置文件的位置。  这通常是通过命令行参数或者预定义的路径来完成的。

2. **读取配置文件:**  根据步骤 1 获取的路径，程序读取配置文件的内容。 配置文件通常包含服务器运行所需的各种参数和配置信息。

   * **解析配置文件:** 读取到的配置文件内容需要进行解析，转换成程序可以理解和使用的格式，例如键值对或者结构化数据。

   * **读取配置文件字段:**  从解析后的配置信息中，读取具体的配置字段。  图中示例列出了两个重要的配置字段：
      * **log_level 日志级别 (log_level 日志级别):**  配置服务器的日志输出级别，例如 DEBUG, INFO, WARN, ERROR 等。
      * **http监听地址和端口 (http监听地址和端口):**  配置服务器监听 HTTP 请求的 IP 地址和端口号。

3. **初始化 mysql 连接池:**  程序初始化 MySQL 数据库连接池。  连接池预先创建并管理一组数据库连接，以便在需要时快速获取，提高数据库访问效率。

4. **初始化 redis 连接池:**  程序初始化 Redis 缓存连接池。  类似于 MySQL 连接池，Redis 连接池用于管理 Redis 缓存的连接，提高缓存访问效率。 

5. **reactor 网络模型:**  程序初始化 Reactor 网络模型。  Reactor 是一种事件驱动的网络编程模型，用于高效地处理网络 I/O 事件。  初始化 Reactor 模型通常包括创建事件循环、注册事件监听器等。

6. **监听指定的IP和端口 并绑定accept新连接后的回调http_callback:**  程序根据配置文件中读取的监听地址和端口，开始监听网络连接。  同时，**绑定 `http_callback` 函数作为处理新连接的回调函数**。  当有新的客户端连接到达时，Reactor 模型会触发 `accept` 事件，并调用 `http_callback` 函数来处理这个新连接。 
   * **新连接触发回调 -> http_callback:**  箭头表示当新连接到达时，会触发 `http_callback` 函数的调用。

7. **将当前进程id写入文件 server.pid:**  程序将当前进程的 ID (PID) 写入 `server.pid` 文件。  这个文件通常用于记录服务器程序的进程 ID，方便后续对服务器进行管理操作，例如停止服务器。

8. **进入epoll_wait触发的循环流程:**  程序进入 Reactor 模型的核心事件循环。  **`epoll_wait`** 是 Linux 系统中高效的 I/O 多路复用系统调用，Reactor 模型使用 `epoll_wait` 监听网络事件，例如连接事件、读写事件等。 程序会一直在这个循环中运行，等待和处理网络事件，直到程序退出。

### 2.3.2 http请求封装处理
一个新的连接 一般都会实例化一个对象绑定连接的fd，这里我们类设计为CHttpConn，所以每个新连接进来后我们要实例化一个CHttpConn对象绑定fd。后续有可读、可写、或者关闭事件的回调都触发httpconn_callback这个函数，通过conn_handle_识别具体是哪个连接。
核心在于CHttpConn::OnRead()的处理。
数据发送完毕后触发CHttpConn::OnWriteComlete()，然后在该回调里关闭连接。


### 2.3.3 CHttpConn::OnRead() 请求数据处理
1. 该怎么处理？先确保能读取到数据，然后把数据打印出来观察。
2. 然后再通过http解析模块进行解析
3. 解析出对应的url后再调用对应的函数处理
4. 处理完毕后，通过CHttpConn::OnWriteComlete()回调函数发送响应数据给客户端。
5. 最后关闭连接。


# 3. 具体业务逻辑
## 3.1 注册/api/reg api_register.cc
**开发逻辑**
1. 定义用户信息表（重点字段）
用户名称和用户昵称都是唯一的，必填字段：
    + 用户名称
    + 用户昵称
    + 用户密码
注册前线查询用户是否存在，如果存在则返回错误，不存在则继续注册。
2. 定义api接口请求/api/reg

**请求和应答**
注册时一个简单的HTTP接口，根据用户输入的注册信息，创建一个新的用户。
请求URL: http://10.168.2.101/api/reg
请求方法：POST
Content-Type: application/json
请求参数:
| 参数名     | 含义     | 规则说明               | 是否必须 | 缺省值 |
| -------- | ------ | ------------------ | -------- | ---- |
| email    | 邮箱     | 必须符合email规范        | 可选     | 无    |
| firstPwd | 密码     | md5加密后的值           | 必填     | 无    |
| nickName | 用户昵称   | 不能超过32个字符          | 必填     | 无    |
| phone    | 手机号码   | 不能超过16个字符          | 可选     | 无    |
| userName | 用户名称   | 不能超过32个字符          | 必填     | 无    |

返回结果参数说明：
| 参数名     | 含义     | 规则说明               |
| -------- | ------ | ------------------ |
| code     | 结果值   | 0：成功； 1：失败； 2：用户已存在      |

示例：
请求示例：
```json
{
    "email": "1094693070@qq.com",
    "firstPwd": "e10adc3949ba59abbe56e057f20f883e",
    "nickName": "lzww",
    "phone": "13566666666",
    "userName": "lzww"
}
```

返回示例：
```json
{
    "code": 0
}
```

**处理逻辑**
客户端发送包含用户信息的 POST 请求到服务器的注册 API 接口，服务器接收请求后进行数据解析、用户校验和数据存储，最终返回 JSON 格式的响应告知客户端注册结果。客户端根据响应状态码进行后续处理，显示注册成功或失败的信息。

## 3.2 登录/api/login api_login.cc
用户信息存储在user_info表中，登录时需要验证用户名和密码。如果对比失败返回错误，对比成功则把token也返回给客户端。
**token用来后续请求做匹配校验（服务器的token存储在redis中）。**

**请求和应答**
登录时一个简单的HTTP接口，根据用户输入的登录信息，验证用户名和密码。
请求URL: http://10.168.2.101/api/login
请求方法：POST
Content-Type: application/json
请求参数:
| 参数名     | 含义     | 规则说明               | 是否必须 | 缺省值 |
| -------- | ------ | ------------------ | -------- | ---- |
| user | 用户名称   | 不能超过32个字符          | 必填     | 无    |
| pwd | 密码     | md5加密后的值           | 必填     | 无    |

返回结果参数说明：
| 参数名     | 含义     | 规则说明               |
| -------- | ------ | ------------------ |
| code     | 结果值   | 0：成功； 1：失败； 2：用户不存在      |
| token    | 令牌   | 每次登录之后都会生成一个token，后续请求需要携带token      |

示例：
请求示例：
```json
{
    "user": "lzww",
    "pwd": "e10adc3949ba59abbe56e057f20f883e"
}
```

返回示例：  
```json
{
    "code": 0,
    "token": "3a58ca22317e637797f8bcad5c047446"
}
```

**处理逻辑**
客户端发送包含用户信息的 POST 请求到服务器的登录 API 接口，服务器接收请求后进行数据解析、用户校验和数据存储，最终返回 JSON 格式的响应告知客户端登录结果。客户端根据响应状态码进行后续处理，显示登录成功或失败的信息。

## 3.3 我的文件列表/api/myfiles&cmd=normal api_myfiles.cc
**开发逻辑**
获取用户文件列表涉及到多表查询
1. 用户文件列表(user_file_list)
*见上文*
2. 文件信息表(file_info)
*见上文*

**请求和应答**
获取用户文件列表时一个简单的HTTP接口，根据用户输入的登录信息，验证用户名和密码。
请求URL: http://10.168.2.101/api/myfiles?cmd=normal
请求方法：POST
Content-Type: application/json
请求参数:
| 参数名     | 含义     | 规则说明               | 是否必须 | 缺省值 |
| -------- | ------ | ------------------ | -------- | ---- |
| token    | 令牌   | 每次登录之后都会生成一个token，后续请求需要携带token      | 必填     | 无    |
| user     | 用户名称   | 不能超过32个字符      | 必填     | 无    |
| count    | 文件数量   | 大于0      | 必填     | 无    |
| start    | 开始位置   | 大于0      | 必填     | 无    |

返回结果参数说明：
| 参数名     | 含义     | 规则说明               |
| -------- | ------ | ------------------ |
| files     | 结果值   | code": 0正常，1失败。 "count": 返回的当前文件数量，比如2。 "total": 个人文件总共的数量。"user": 用户名称。"md5": md5值。"create_time": 创建时间。"file_name": 文件名。"share_status": 共享状态, 0为没有共享， 1为共享。"pv": 文件下载量，下载一次加1。 "url": URL。"size": 文件大小。"type": 文件类型。      |


示例：
请求示例：
```json
{
    "count": 10,
    "start": 0,
    "token": "nwlrbbmqbhcdarzowkkyhiddqscdxrjm",
    "user": "lzww"
}
```

返回示例：
*太长了，这里就不贴了*

**处理逻辑**
客户端通过 POST 请求发送分页参数、用户身份信息到服务器的 /api/myfiles 接口。服务器端进行参数解析、用户身份验证，并从 MySQL 数据库中查询用户的文件列表，最终将文件列表以 JSON 格式返回给客户端。客户端根据响应状态码和文件列表数据进行后续处理。


